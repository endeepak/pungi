{"name":"Pungi","tagline":"Simple and powerful mocking framework with extensible assertion matchers (Inspired by jasmine BDD framework)","body":"Pungi [![Build Status](https://travis-ci.org/endeepak/pungi.png)](https://travis-ci.org/endeepak/pungi)\r\n=====\r\n\r\nSimple and powerful python mocking framework with extensible assertion matchers (Inspired by [jasmine](https://github.com/pivotal/jasmine/wiki/Spies) BDD framework)\r\n\r\n[define:pungi](http://www.google.com/search?q=define:pungi)\r\n\r\nThis documentation is for the latest code on this branch. For earlier versions, please refer to corresponding [tags](https://github.com/endeepak/pungi/tags).\r\n\r\nInstall\r\n=======\r\n\r\n        pip install pungi\r\n\r\n\r\nIntention of this library\r\n=========================\r\n\r\n* The library should have simple interface and easily extensible.\r\n* Mocking a method or creating mock/stub object should simply be one line code.\r\n* The tests should not contain any mock replay and verify steps.\r\n* The expectations should be asserted after the action is performed.\r\n\r\nMocking with spies\r\n==================\r\n\r\nThis mocking library is based on AAA(Arrange Act Assert) pattern. It is built to be simple and easy to use without having to know about how the internals work.\r\n\r\n        from pungi import spyOn, createSpy, expect, any\r\n\r\nMocking a class/instance method\r\n-------------------------------\r\n\r\n        spyOn(x, 'method') #Arrange\r\n\r\n        x.method() #Act\r\n\r\n        expect(x.method).toHaveBeenCalled() #Assert\r\n\r\nThe toHaveBeenCalled matcher can take optional argument *times* to indicate number times method should have been called\r\n\r\n        expect(x.method).toHaveBeenCalled(times = 2)\r\n\r\nAsserting arguments passed to method call\r\n\r\n        expect(x.method).toHaveBeenCalledWith(foo, bar=1)\r\n        expect(x.method).toHaveBeenCalledWith(foo, bar=any(int))\r\n\r\nIf you do not want to use the above syntax, you can do the same as:\r\n\r\n        assertTrue(x.method.wasCalled(times=2)) # The failure message will not be as pretty as the *expect* syntax.\r\n        assertTrue(x.method.wasCalledWith(foo, bar=1))\r\n\r\nAll the expect matchers will have a corresponding negative assertion matcher.\r\n\r\n        expect(x.method).notToHaveBeenCalled()\r\n        expect(x.method).notToHaveBeenCalledWith(foo, bar=1)\r\n        expect(x.method).notToHaveBeenCalledWith(foo, bar=any(int))\r\n\r\nThe spy can be configured in several ways\r\n\r\n        spyOn(x, 'method').andReturn(foo) # x.method() returns foo\r\n\r\n        spyOn(x, 'method').andRaise(SomeException, \"Message Args\") # raise this exception on calling x.method()\r\n\r\n        spyOn(x, 'method').andCallThrough() # Call the original method, but record the call which can be used for assertion\r\n\r\n        spyOn(x, 'method').andCallFake(some_function) # Call the fake method and record the call\r\n\r\nSame can be done with alternate syntax\r\n\r\n        spyOn(x, 'method', returnValue=foo)\r\n        spyOn(x, 'method', raiseException=SomeException)\r\n        spyOn(x, 'method', callThrough=True)\r\n        spyOn(x, 'method', callFake=some_func)\r\n\r\nThe spied method contains useful methods\r\n\r\n        x.method.callCount # Number of times x.method() was called\r\n\r\n        x.method.mostRecentCall\r\n        x.method.mostRecentCall.received(*args, **kwargs) # True or False\r\n        x.method.mostRecentCall.args # Positional arguments(*args) passed to the method\r\n        x.method.mostRecentCall.kwargs # Named arguments(**kwargs) passed to the method\r\n\r\n        x.method.argsForCall(index) # args for nth call\r\n        x.method.kwargsForCall(index) # kwargs for nth call\r\n\r\nMocking a class method is same as above:\r\n\r\n      spyOn(FooClass, 'some_class_method')\r\n\r\nCleaning up spies\r\n-----------------\r\n\r\nThe spies can be cleared in few ways:\r\n\r\n* Decorating the test case\r\n\r\n        @pungi.dec.testcase\r\n        class ClassDecoratorTest(unittest.TestCase): #Spies are cleared after every test(methods with 'test' in name)\r\n\r\n* Decorating individual tests\r\n\r\n        @pungi.dec.test\r\n        def test_method(self):\r\n\r\n* Add a teardown method which calls *pungi.stopSpying()*\r\n\r\n* Use spy inside a *with* block\r\n\r\n        with spyOn(x, 'method', returnValue=foo):\r\n              x.method() # returns foo\r\n\r\n        x.method() # returns actual value\r\n\r\nCreating mock/stub objects\r\n--------------------------\r\n\r\nThe createSpy method creates a mock/stub object with an optional name, this object records all the method calls.\r\n\r\n        x = createSpy(\"greeter\")\r\n\r\n        x.say_hello(to='world')\r\n\r\n        expect(x.say_hello).wasCalledWith(to='world')\r\n\r\nThe assertion syntax remains the same. Cleaning up spy objects is same as above. The individual methods on spy object can be setup using *spyOn* method shown above. The alternate syntax for setting up multiple methods with return values is:\r\n\r\n        x = createSpy(\"person\", age=20, balance=20000)\r\n\r\nor you can configure individual methods\r\n\r\n       x.age.returnValue = 20\r\n       x.foo.callFake = fake_method\r\n       x.bar.raiseException = SomeException\r\n\r\nChaining methods and spies\r\n--------------------------\r\n\r\nThe spied methods return *spy objects* by default. Hence you need to define a spy only once in the complete method chain.\r\n\r\n      spyOn(x, 'method')\r\n\r\n      x.method().another_method().foo()\r\n\r\n      x.method.callCount # 1\r\n      x.method().another_method.callCount # 1\r\n      x.method().another_method().foo.callCount # 1\r\n\r\nThe behavior is same for spies created using *createSpy* method.\r\n\r\n      greeter = createSpy('greeter')\r\n\r\n      greeter.say().hello().to().world()\r\n\r\n\r\nAsserting the order in which methods are called\r\n-----------------------------------------------\r\n\r\nThe method call order is tracked for every test. This order can be accessed as\r\n\r\n      x.method.callNumber # Number indicating global order in which x.method was called\r\n\r\nIt can asserted be as\r\n\r\n      expect(obj.hi).toHaveBeenCalledBefore(obj.hello)\r\n\r\n      or\r\n\r\n      assertTrue(obj.hi.wasCalledBefore(obj.hello))\r\n\r\n\r\nUsing expect matchers\r\n=====================\r\n\r\nThere are several inbuilt assertion matchers apart from the spy expectation matchers shown above.\r\n\r\n        expect(1 + 1).toBe(2)\r\n        expect(1 + 1).toEqual(2)\r\n\r\n        expect(x).toBeNone()\r\n        expect(x).toBeTruthy()\r\n        expect(x).toBeFalsy()\r\n\r\n        expect(\"abcd\").toMatch(\".*b.*\")\r\n\r\n        expect(\"abcd\").toContain(\"b\")\r\n        expect([1, 2, 3]).toContain(2)\r\n\r\n        expect(2).toBeGreaterThan(1)\r\n        expect(1).toBeLessThan(2)\r\n\r\n        expect(raise_ex).toRaise(SomeException)\r\n        expect(raise_ex).toRaise(SomeException, \"Message\")\r\n        expect(raise_ex).toRaise(SomeException(\"Message\"))        \r\n\r\nAll the above matchers have corresponding negative('notTo') matchers.\r\n\r\n        expect(foo).notToBe(bar)\r\n\r\nAdding custom matchers\r\n----------------------\r\n\r\nThe matchers are easily extensible to allow domain specific custom matchers to improve the readability of test. The custom matcher has to be a class which inherits from *pungi.matchers.Base* and implement *matches* method and optionally message method.\r\n\r\n        class ToHaveAttr(pungi.matchers.Base):\r\n            def matches(self, expectedAttrName):\r\n                return hasattr(self.actual, expectedAttrName)\r\n\r\nAdd the matchers as\r\n\r\n        pungi.matchers.add(ToHaveAttr, SomeMoreMatchers, ..)\r\n\r\nThe matcher is used as\r\n\r\n        expect(foo).toHaveAttr('bar')\r\n        expect(foo).notToHaveAttr('qux')\r\n\r\nMore examples on defining a matcher can be found [here](https://github.com/endeepak/pungi/blob/master/pungi/matchers.py)\r\n\r\n\r\nContributing\r\n============\r\n\r\n* Issues and feature requests can be added [here](https://github.com/endeepak/pungi/issues/new)\r\n\r\n* If an issue can reproduced in the form of a test, fork the project and raise a [pull request](https://github.com/endeepak/pungi/pull/new/master)\r\n\r\nSupport\r\n=======\r\nThe tests pass with python 2.6 and 2.7. Please check the [build matrix](https://travis-ci.org/endeepak/pungi) for more details.\r\n\r\nMiscellaneous\r\n=============\r\nThis library has been tested unittest framework. It may or may not work with other testing frameworks. If you notice any failures, please report the issue [here](https://github.com/endeepak/pungi/issues/new).\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}